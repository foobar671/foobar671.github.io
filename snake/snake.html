<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <script type="application/javascript">
  
	// Game grid variables. Note that we map increasing Y to higher row number.
	var numGridRows = 30;
	var numGridCols = numGridRows;	
	var gameGrid = new Array();
	var totalGridWidthInPixels = 600.0;
	var totalGridHeightInPixels = 600.0;
	
	// Snake properties
	var initialSnakeHeadPositionX = Math.floor(numGridCols/2);
    var initialSnakeHeadPositionY = Math.floor(numGridRows/2);
	var currSnakeHeadPosX = initialSnakeHeadPositionX;
	var currSnakeHeadPosY = initialSnakeHeadPositionY;
	var numInitialSnakeBodySegments = 5;
	var snakeBodySegments = new Array();
	var snakeDirections = {up:0,down:1,left:2,right:3};
	var initialSnakeDirection = snakeDirections.up;
	var currSnakeDirection = initialSnakeDirection;
	var nextRequestedSnakeDirection = initialSnakeDirection;
	var cellsToMoveSnakePerFrame = 0.1; // (0,1]
	var snakeHeadColor = "#FF0000"; // red
	var snakeBodyColor = "#008000"; // green
	
	// Apple properties
	var applePointAward = 10;
	var apples = new Array();
	var appleColor = "#0000FF"; // blue
	
	// Game grid contents IDs
	var empty = 0;
	var snakeBody = 1;
	var snakeHead = 2;
	var apple = 3;
	
	// Game grid properties
	var gridColor = "#000000"; // black
	var borderColor = "#000000"; // black
	
	// Miscellaneous global game properties
	var score = 0;
	var gameOver = false;
	var updateTimeMS = 16.0; // ~60 FPS
	var snakeMovementAccumulator = 0.0;
	var debug = false;
	
	function initializeGameGrid()
	{
		for (i = 0; i < numGridRows; i++)
		{
		    gameGrid[i] = new Array();
			for (j = 0; j < numGridCols; j++)
			{
				gameGrid[i][j] = 0;
			}
		}
	}
	
	function initializeSnake()
	{
		// Should add some bounds checking
		gameGrid[initialSnakeHeadPositionX][initialSnakeHeadPositionY] = snakeHead;
		for (i = 0; i < numInitialSnakeBodySegments; i++)
		{
			// [row][col]
			xCoord = initialSnakeHeadPositionX;
			yCoord = initialSnakeHeadPositionY + i + 1;
			gameGrid[yCoord][xCoord] = snakeBody;
			var snakeBodySegment = {xCoord:xCoord, yCoord:yCoord};
			snakeBodySegments.push(snakeBodySegment);
		}
	}
	
	function addApple()
	{
		// Right now very simple. Note Math.random() is [0,1)
		var appleX = Math.floor(Math.random() * numGridCols);
		var appleY = Math.floor(Math.random() * numGridRows);
		var appleObj = {appleX:appleX, appleY:appleY};
		apples.push(appleObj); // Add to explicit tracking array
		gameGrid[appleY][appleX] = apple; // Add to game grid
	}
	
	// This is terrible... But the apple array will be small.
	function removeApple(appleX, appleY)
	{
		// Remove from explicit tracking array
		for (i = 0; i < apples.length; i++)
		{
			currAppleObj = apples[i];
			currAppleX = currAppleObj.appleX;
			currAppleY = currAppleObj.appleY;
			
			if (currAppleX == appleX && currAppleY == appleY)
			{
				apples.splice(i,1);
				break;
			}
		}
		
		// Remove from game grid
		gameGrid[appleY][appleX] = empty;
	}
	
	function initializeGame()
	{
		initializeGameGrid();
		initializeSnake();
		addApple();
	}

	function drawGrid(drawData)
	{
		drawData.ctx.fillStyle = gridColor;
		var currOffsetX = 0;
		var currOffsetY = 0;
		
		for (row = 0; row < numGridRows; row++)
		{
			for (col = 0; col < numGridCols; col++)
			{
				drawData.ctx.rect(
					drawData.gridZeroXCoord + currOffsetX,
					drawData.gridZeroYCoord + currOffsetY,
					drawData.pixelsPerGridCellSide,
					drawData.pixelsPerGridCellSide);		
				drawData.ctx.stroke();
				
				currOffsetY += drawData.pixelsPerGridCellSide;
			}
			
			currOffsetY = 0;
			currOffsetX += drawData.pixelsPerGridCellSide;
		}
	}
	
	function drawGridBorder(drawData)
	{
		drawData.ctx.fillStyle = borderColor;
		drawData.ctx.rect(
			drawData.gridZeroXCoord, drawData.gridZeroYCoord,
			totalGridWidthInPixels, totalGridHeightInPixels);
		drawData.ctx.stroke();
	}
	
	function drawGameElements(drawData)
	{
		var ctx = drawData.ctx;
		
		for (row = 0; row < numGridRows; row++)
		{
			for (col = 0; col < numGridCols; col++)
			{
				var cellZeroX = drawData.gridZeroXCoord + col*drawData.pixelsPerGridCellSide;
				var cellZeroY = drawData.gridZeroYCoord + row*drawData.pixelsPerGridCellSide;
				var centerX = cellZeroX + 0.5*drawData.pixelsPerGridCellSide;
			    var centerY = cellZeroY + 0.5*drawData.pixelsPerGridCellSide;
				var radius = 0.5*drawData.pixelsPerGridCellSide;
				
				var entityID = gameGrid[row][col];	
				switch(entityID)
				{
					case snakeBody:
						// x, y, radius, startAngle, endAngle, anticlockwise
						ctx.fillStyle = snakeBodyColor;
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, 0, Math.PI*2, true);
						ctx.closePath();
						ctx.fill();
					break;
					
					case snakeHead:
						// x, y, radius, startAngle, endAngle, anticlockwise
						ctx.fillStyle = snakeHeadColor;
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, 0, Math.PI*2, true);
						ctx.closePath();
						ctx.fill();
					break;
					
					case apple:
						// x, y, radius, startAngle, endAngle, anticlockwise
						ctx.fillStyle = appleColor;
						ctx.beginPath();
						ctx.arc(centerX, centerY, radius, 0, Math.PI*2, true);
						ctx.closePath();
						ctx.fill();
					break;
				}
			}
		}
	}
	
	function moveSnake()
	{
		snakeMovementAccumulator += cellsToMoveSnakePerFrame;
		if (snakeMovementAccumulator < 1.0) return;
		
		currSnakeDirection = nextRequestedSnakeDirection;
		snakeMovementAccumulator = 0.0;
		var prevSegmentLocationX = currSnakeHeadPosX;
		var prevSegmentLocationY = currSnakeHeadPosY;
		
		// Move the head
		switch (currSnakeDirection)
		{
			case snakeDirections.up:
				currSnakeHeadPosY -= 1;
			break;
			case snakeDirections.down:
				currSnakeHeadPosY += 1;
			break;
			case snakeDirections.left:
				currSnakeHeadPosX -= 1;
			break;
			case snakeDirections.right:
				currSnakeHeadPosX += 1;
			break;
		}
		
		if (headIsOutOfBounds()) return;
		
		gameGrid[prevSegmentLocationY][prevSegmentLocationX] = empty;
		
		// Update the body
		for (i = 0; i < snakeBodySegments.length; i++)
		{	
			currSegmentLocationX = snakeBodySegments[i].xCoord;
			currSegmentLocationY = snakeBodySegments[i].yCoord;
			
			gameGrid[currSegmentLocationY][currSegmentLocationX] = empty;
			gameGrid[prevSegmentLocationY][prevSegmentLocationX] = snakeBody;
			
			var newSegmentLoc = {xCoord:prevSegmentLocationX, yCoord:prevSegmentLocationY};
			snakeBodySegments[i] = newSegmentLoc;
			
			if (prevSegmentLocationX == currSnakeHeadPosX &&
				prevSegmentLocationY == currSnakeHeadPosY)
			{
				// Head - body collision! Stop right there!
				gameOver = true;
			}
			
			prevSegmentLocationX = currSegmentLocationX;
			prevSegmentLocationY = currSegmentLocationY;
		}
		
		gameGrid[currSnakeHeadPosY][currSnakeHeadPosX] = snakeHead;
	}
	
	function headIsOutOfBounds()
	{
		if (currSnakeHeadPosX < 0 ||
		    currSnakeHeadPosY < 0 ||
			currSnakeHeadPosX >= numGridCols ||
			currSnakeHeadPosY >= numGridRows)
		{
			return true;
		}
		return false;
	}
	
	function detectCollisionsAndUpdateScore()
	{
		// Must check OOB-induced game over first.
		if (headIsOutOfBounds())
		{
			gameOver = true;
			return;
		}
	
		// [row][col]
		var snakeHeadCellEntityID = gameGrid[currSnakeHeadPosY][currSnakeHeadPosX];
		switch(snakeHeadCellEntityID)
		{
			case snakeBody:
				gameOver = true;
			break;
			
			case apple:
				removeApple(currSnakeHeadPosX, currSnakeHeadPosY);
				score += applePointAward;
			break;
		}
	}
	
	function updateGameState()
	{
		moveSnake();
		detectCollisionsAndUpdateScore();
	}
	
	function drawGame()
	{
		var canvas = document.getElementById("canvas");
		if (canvas.getContext)
		{	 
		  var ctx = canvas.getContext("2d");
		  ctx.canvas.width  = window.innerWidth;
		  ctx.canvas.height = window.innerHeight;
		  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		  
		  var canvasWidth = ctx.canvas.width;
		  var canvasHeight = ctx.canvas.height;
		  var totalGridPixels = totalGridWidthInPixels*totalGridHeightInPixels;
		  var totalGridCells = numGridRows*numGridCols;	
		  var pixelsPerGridCell  = totalGridPixels / totalGridCells;
		  var pixelsPerGridCellSide = Math.sqrt(pixelsPerGridCell);
		  
		  // Compute X and Y offsets to draw the game grid centered on canvas.
		  var gridZeroXCoord = ctx.canvas.width * 0.5 - ( 0.5 * totalGridWidthInPixels);
		  var gridZeroYCoord = ctx.canvas.height * 0.5 - ( 0.5 * totalGridHeightInPixels);
		  
		  var drawData = {
			ctx:ctx,
			canvasWidth:canvasWidth,
			canvasHeight:canvasHeight,
			pixelsPerGridCell:pixelsPerGridCell,
			pixelsPerGridCellSide:pixelsPerGridCellSide,
			gridZeroXCoord:gridZeroXCoord,
			gridZeroYCoord:gridZeroYCoord
		  };
		   
		  drawGridBorder(drawData);
		  if (debug){
			drawGrid(drawData);
		  }
		  drawGameElements(drawData);
		}
	}
	
    function mainGameLoop()
	{		  
      var tStart = performance.now();
	  if (!gameOver) updateGameState();
	  drawGame();
	  var tEnd = performance.now();
	  var frameTimeMS = tEnd - tStart;
	  
	  if (debug){
		console.log("Frame time: " + frameTimeMS + " milliseconds.");
	  }
	  if (updateTimeMS - frameTimeMS > 0.0){
		console.log("Setting timeout to " + (updateTimeMS-frameTimeMS) + "MS");
		setTimeout(mainGameLoop, updateTimeMS - frameTimeMS);
	  }
	  else {
		setTimeout(mainGameLoop, 0);
	  }
    }
	
	function onKeyDown(event)
	{	  
		var keyCode = event.keyCode;
		event.preventDefault();
		switch (keyCode)
		{
			case 37:
				// left arrow
				if (currSnakeDirection == snakeDirections.right) return;
				nextRequestedSnakeDirection = snakeDirections.left;
			break;
			
			case 38:
				// up arrow
				if (currSnakeDirection == snakeDirections.down) return;
				nextRequestedSnakeDirection = snakeDirections.up;
			break;
			
			case 39:
				// right arrow
				if (currSnakeDirection == snakeDirections.left) return;
				nextRequestedSnakeDirection = snakeDirections.right;

			break;
			
			case 40:
				// down arrow
				if (currSnakeDirection == snakeDirections.up) return;
				nextRequestedSnakeDirection = snakeDirections.down;
			break;
		}
	}
	
	function main()
	{
		//var snd = document.getElementById('noise');
		//snd.src = 'ttyd.mp3';
		//snd.load();
		//snd.play();
		document.addEventListener('keydown', onKeyDown);
		initializeGame();
		mainGameLoop();
	}
  </script>
  
 <title>Sssssnake</title>
 </head>
 <body onload="main();">
   <canvas id="canvas"></canvas>
   <audio id="noise"></audio>
 </body>
</html>